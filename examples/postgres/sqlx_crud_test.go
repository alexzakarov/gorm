package postgres

import (
	"fmt"
	pgConfig "github.com/alexzakarov/grogu/config"
	"github.com/alexzakarov/grogu/database/ports"
	"github.com/alexzakarov/grogu/database/postgres"
	repos "github.com/alexzakarov/grogu/database/postgres/base_repo/postgres"
	"github.com/alexzakarov/grogu/examples"
	"github.com/alexzakarov/grogu/examples/postgres/config"
	"github.com/alexzakarov/grogu/logger"
	"github.com/stretchr/testify/assert"
	"log"
	"reflect"
	"testing"
)

func init() {
	var baseDB ports.IBaseDb
	cfg, errConfig := config.ParseConfig()
	if errConfig != nil {
		log.Fatal(errConfig)
	}
	appLogger = logger.NewApiLogger(cfg)
	appLogger.InitLogger()

	tableQuery := `CREATE TABLE IF NOT EXISTS public.users (
     	user_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
		meta_data VARCHAR(255) DEFAULT NULL,
		user_title VARCHAR(75) DEFAULT NULL
	)`

	// Init Clients
	baseDB, err = postgres.NewSQLXPostgresqlDB(pgConfig.SQLXDbConfig{
		Host:      cfg.Postgresql.HOST,
		Port:      cfg.Postgresql.PORT,
		User:      cfg.Postgresql.USER,
		Pass:      cfg.Postgresql.PASS,
		DefaultDb: cfg.Postgresql.DEFAULT_DB,
	})
	if err != nil {
		appLogger.Error("Error when tyring to connect to Postgresql")
	} else {
		appLogger.Info("Postgresql connected")
	}

	_, err = baseDB.Exec(tableQuery)
	if err != nil {
		println(err.Error())
		return
	}

	//status_type gets two values which can be "int" or "bool"
	//status int:
	//    1 - Active
	//    2 - Passive
	//    3 - Block
	//    4 - Delete
	//status bool:
	//    1 - Active
	//    2 - Passive
	sqlxRepo = repos.NewPostgresBaseRepo[examples.CreateUserDbModel, examples.UpdateUserDbModel, examples.UserResDto](pgConfig.SQLXBaseRepoConfig{
		Db: baseDB,
		GeneralConfig: pgConfig.GeneralConfig{
			Table:         "public.users",
			PrimaryKey:    "user_id",
			SoftDeletable: false,
			StatusName:    "",
			StatusType:    "",
		},
	}.ToPostgresConfig())
}

func TestSQLXCreate(t *testing.T) {
	assertion := assert.New(t)

	var (
		record int64
	)

	user := examples.CreateUserReqDto{
		UserTitle: "Test User",
	}
	meta := user.ToDbModel("This user has admin role")

	sqlxRepo.Create(meta, func(id int64) {
		record = 1
		userId = id
	}, func(rec int64) {
		// negative rec refers to db errors
		record = rec
	})

	assertion.Equal(int64(1), record, "User cannot be created")

}

func TestSQLXUpdate(t *testing.T) {
	assertion := assert.New(t)

	var (
		record int64
	)

	user := examples.UpdateUserReqDto{
		UserTitle: "Test User",
	}
	meta := user.ToDbModel("This user has admin role updated")
	sqlxRepo.Update(userId, meta, func() {
		record = 1
	}, func(rec int64) {
		// negative rec refers to db errors
		record = rec
	})

	assertion.Equal(int64(1), record, fmt.Sprintf("User cannot be updated; User ID: %d", userId))

}

func TestSQLXGetOne(t *testing.T) {
	assertion := assert.New(t)

	var (
		record int64
	)

	sqlxRepo.GetOne(userId, func(user examples.UserResDto) {
		record = 1
		_ = user
	}, func(rec int64) {
		// negative rec refers to db errors
		record = rec
	})

	assertion.Equal(int64(1), record, fmt.Sprintf("failed to retrieve user; User ID: %d", userId))
}

func TestSQLXDeleteOne(t *testing.T) {
	assertion := assert.New(t)

	var (
		record int64
	)

	sqlxRepo.DeleteOne(userId, func() {
		record = 1
	}, func(rec int64) {
		// negative rec refers to db errors
		record = rec
	})

	assertion.Equal(int64(1), record, fmt.Sprintf("User cannot be deleted; User ID: %d", userId))

}

func BenchmarkAllSQLX(b *testing.B) {
	for i := 0; i < b.N; i++ {
		TestSQLXCreate(&testing.T{})
		TestSQLXUpdate(&testing.T{})
		TestSQLXGetOne(&testing.T{})
		TestSQLXDeleteOne(&testing.T{})
	}
}

func BenchmarkSQLXCreate(b *testing.B) {
	var test int64
	fmt.Println(reflect.TypeOf(reflect.TypeOf(test)))
	for i := 0; i < b.N; i++ {
		TestSQLXCreate(&testing.T{})
	}
}
func BenchmarkSQLXUpdate(b *testing.B) {
	for i := 0; i < b.N; i++ {
		TestSQLXUpdate(&testing.T{})
	}
}
func BenchmarkSQLXGetOne(b *testing.B) {
	for i := 0; i < b.N; i++ {
		TestSQLXGetOne(&testing.T{})
	}
}

func BenchmarkSQLXDeleteOne(b *testing.B) {
	for i := 0; i < b.N; i++ {
		TestSQLXDeleteOne(&testing.T{})
	}
}
