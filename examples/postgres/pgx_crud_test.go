package postgres

import (
	"fmt"
	postgres2 "github.com/alexzakarov/grogu/base_repo/postgres"
	pgConfig "github.com/alexzakarov/grogu/config"
	"github.com/alexzakarov/grogu/database/postgres"
	"github.com/alexzakarov/grogu/examples"
	"github.com/alexzakarov/grogu/examples/postgres/config"
	"github.com/alexzakarov/grogu/logger"
	"github.com/stretchr/testify/assert"
	"log"
	"testing"
)

func init() {
	cfg, errConfig := config.ParseConfig()
	if errConfig != nil {
		log.Fatal(errConfig)
	}
	appLogger = logger.NewApiLogger(cfg)
	appLogger.InitLogger()

	tableQuery := `CREATE TABLE IF NOT EXISTS public.users (
     	user_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
		meta_data VARCHAR(255) DEFAULT NULL,
		user_title VARCHAR(75) DEFAULT NULL
	)`

	// Init Clients
	pgxDb, err = postgres.NewPGXPostgresqlDB(cfg)
	if err != nil {
		appLogger.Error("Error when tyring to connect to Postgresql")
	} else {
		appLogger.Info("Postgresql connected")
	}

	_, err = pgxDb.Exec(ctx, tableQuery)
	if err != nil {
		println(err.Error())
		return
	}

	//status_type gets two values which can be "int" or "bool"
	//status int:
	//    1 - Active
	//    2 - Passive
	//    3 - Block
	//    4 - Delete
	//status bool:
	//    1 - Active
	//    2 - Passive
	pgxBaseRepo = postgres2.NewPGXBaseRepo[examples.CreateUserDbModel, examples.UpdateUserDbModel, examples.UserResDto](pgConfig.PGXPostgresConfig{
		Ctx: ctx,
		Db:  pgxDb,
		GeneralConfig: pgConfig.GeneralConfig{
			Schema:        "public",
			Table:         "users",
			PrimaryKey:    "user_id",
			SoftDeletable: false,
			StatusName:    "",
			StatusType:    "",
		},
	})
}

func TestPGXCreate(t *testing.T) {
	assertion := assert.New(t)

	var (
		record int64
	)

	user := examples.CreateUserReqDto{
		UserTitle: "Test User",
	}
	meta := user.ToDbModel("This user has admin role")

	pgxBaseRepo.Create(meta, func(id int64) {
		record = 1
		userId = id
	}, func(rec int64) {
		// negative rec refers to db errors
		record = rec
	})

	assertion.Equal(int64(1), record, "User cannot be created")

}

func TestPGXUpdate(t *testing.T) {
	assertion := assert.New(t)

	var (
		record int64
	)

	user := examples.UpdateUserReqDto{
		UserTitle: "Test User",
	}
	meta := user.ToDbModel("This user has admin role")
	pgxBaseRepo.Update(userId, meta, func() {
		record = 1
	}, func(rec int64) {
		// negative rec refers to db errors
		record = rec
	})

	assertion.Equal(int64(1), record, fmt.Sprintf("User cannot be updated; User ID: %d", userId))

}

func TestPGXGetOne(t *testing.T) {
	assertion := assert.New(t)

	var (
		record int64
	)

	pgxBaseRepo.GetOne(userId, func(user examples.UserResDto) {
		record = 1
		_ = user
	}, func(rec int64) {
		// negative rec refers to db errors
		record = rec
	})

	assertion.Equal(int64(1), record, fmt.Sprintf("failed to retrieve user; User ID: %d", userId))
}

func TestPGXDeleteOne(t *testing.T) {
	assertion := assert.New(t)

	var (
		record int64
	)

	pgxBaseRepo.DeleteOne(userId, func() {
		record = 1
	}, func(rec int64) {
		// negative rec refers to db errors
		record = rec
	})

	assertion.Equal(int64(1), record, fmt.Sprintf("User cannot be deleted; User ID: %d", userId))

}

func BenchmarkAllPGX(b *testing.B) {
	for i := 0; i < b.N; i++ {
		TestPGXCreate(&testing.T{})
		TestPGXUpdate(&testing.T{})
		TestPGXGetOne(&testing.T{})
		TestPGXDeleteOne(&testing.T{})
	}
}

func BenchmarkPGXCreate(b *testing.B) {
	for i := 0; i < b.N; i++ {
		TestPGXCreate(&testing.T{})
	}
}
func BenchmarkPGXUpdate(b *testing.B) {
	for i := 0; i < b.N; i++ {
		TestPGXUpdate(&testing.T{})
	}
}
func BenchmarkPGXGetOne(b *testing.B) {
	for i := 0; i < b.N; i++ {
		TestPGXGetOne(&testing.T{})
	}
}

func BenchmarkPGXDeleteOne(b *testing.B) {
	for i := 0; i < b.N; i++ {
		TestPGXDeleteOne(&testing.T{})
	}
}
